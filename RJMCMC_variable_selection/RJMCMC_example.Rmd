---
title: "Reversible Jump MCMC"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, 
  fig.align = "center")

library(nimble)
```

Reversible Jump MCMC (RJMCMC) is a method for sampling across models with a different numbers of dimensions, which founds natural application in Bayesian variable selection problems.
NIMBLE implements RJMCMC for variable selection using a univariate Normal distribution as proposal density and supports two types of model specifications, depending on whether or not 
indicator variables are included in the model.
In the following we consider a case including indicator variables, and refer to the user manual and `help(configure_RJ)` for additional information on the other case. 

## Linear regression example

For simplicity we consider a linear regression example in which we have $15$ explanatory variables, and $5$ of those are real effects while the others have null effects, i.e. the corresponding coefficient is equal to $0$.  


```{r nimble_model}
lmCode <- nimbleCode({
  sigma ~ dunif(0, 20)
  psi ~ dunif(0,1)   ## prior on inclusion probability
  
  for(i in 1:numVars) {
    z[i] ~ dbern(psi) ## indicator variable for each coefficient
    beta[i] ~ dnorm(0, sd = 100)  
    zbeta[i] <- z[i] * beta[i]  ## indicator * beta
  }
  for(i in 1:n) {
    pred.y[i] <- inprod(X[i, 1:numVars], zbeta[1:numVars])
    y[i] ~ dnorm(pred.y[i], sd = sigma)
  }
})
## Generate data and define model constants
set.seed(1)
numVars = 15
n = 100
X <- matrix(rnorm(n*numVars), nrow = n, ncol = numVars)
lmConstants <- list(numVars = numVars, n = n, X = X)
lmModel <- nimbleModel(lmCode, constants = lmConstants)
```

We can simulate data using the `nimbleModel` we just created by initializing the model parameters and calling the `simulate()` method. 

```{r simulate_data, message = F}
true_betas <- c(c(0.1, 0.2, 0.3, 0.4, 0.5),
                rep(0, 10))

lmModel$beta <- true_betas
lmModel$sigma <- 1
lmModel$z <- rep(1, 15)
lmModel$psi <- 0.5
lmModel$calculate()
set.seed(0) ## Make this reproducible
lmModel$simulate('y')
lmModel$calculate() 
lmModel$setData('y')
lmData = list(y = lmModel$y)

```

<!-- For comparison we look first to simple linear regression:

```{r use_lm}
summary(lm(lmModel$y ~ lmModel$X))
```
 -->

## Configuring RJMCMC

The RJCMCM sampler can be added to the MCMC configuration by calling the function `configureRJ()`. In the example considered we introduced the vector `z` as indicator variables associated with the regression coefficients `beta`. We can pass them to `configureRJ` using the arguments `indicatorNodes` and `targetNodes`. The `control` argument allows to specify the mean and the scale of the normal proposal distribution. 

```{r configure_RJ}
lmConf <- configureMCMC(lmModel)
lmConf$addMonitors('z')
configureRJ(lmConf,
            targetNodes = 'beta',
            indicatorNodes = 'z',
            control = list(mean = 0, scale = .2))
```


Checking the assigned samplers we can notice indicator variables are assigned to an `RJ_indicator` sampler whose `targetNode` is the corresponding coefficient, while `beta` parameters are assigned to a `toggled` sampler which update the parameter only when it is included in the model. 

```{r }
## Check the assigned samplers
lmConf$printSamplers(c("z[1]", "beta[1]"))

```

## Build and run the RJMCMC

```{r build_run_model}
mcmcRJ <- buildMCMC(lmConf)

cLmModel <- compileNimble(lmModel)
CMCMCRJ <- compileNimble(mcmcRJ, project = lmModel)
set.seed(100)
# set.seed(1)
system.time(samples_nimble <- runMCMC(CMCMCRJ, niter = 100000, nburnin = 10000))
```

## Looking at the results
<!-- post-processing : variables probabilities, model probabilities -->

For each variable we can look at the sampled values, and the value of the corresponding indicator variable.

```{r, fig.align = "center"}
plot(samples_nimble[,'beta[1]'], pch = '.', main = "beta[1] traceplot")
plot(samples_nimble[,'z[1]'], pch = '.', main = "z[1] traceplot")
```

```{r}
plot(samples_nimble[,'beta[5]'], pch = '.', main = "beta[5] traceplot")
plot(samples_nimble[,'z[5]'], pch = '.', main = "z[5] traceplot")
```

### Posterior inclusion probability, `psi`


```{r}
plot(density(samples_nimble[,'psi']), main = "Inclusion probability", xlab = "Probability", ylab = "Density")
```

### Individual inclusion probabilities

```{r}
zCols <- grep("z\\[", colnames(samples_nimble))
posterior_inclusion_prob <- colMeans(samples_nimble[,zCols])
plot(1:length(true_betas), posterior_inclusion_prob,
  xaxt = 'none', 
	xlab = "beta", ylab = "Inclusion probability", 
	main = "Inclusion probabilities for each beta")
axis(1, seq(0,15,1))
```

### Model probabilities

Finally we can look at the probabilities associated to each possible model, coded by the vector of indicator variables `z`.

```{r, message = F, warning = F}
library(data.table)

binary <- as.data.table((samples_nimble[, zCols] != 0)+ 0)
res <- binary[,.N, by=names(binary)]
res <-res[order(N, decreasing = T)]
res <- res[, prob := N/dim(samples_nimble)[1]]
  
res[1:5, ]

```

<!-- Alternative in base R

nSamples <- dim(samples_nimble)[1]
binary <- as.data.frame((samples_nimble[, zCols] != 0)+ 0)
res <- binary[,.N, by=names(binary)]
dd <- table(do.call(paste, binary))
(sort(dd, decreasing = T)/nSamples)[1:5]
 -->