<!DOCTYPE html>
<html>
<head>
<style type="text/css">
.knitr .inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.rimage .left {
  text-align: left;
}
.rimage .right {
  text-align: right;
}
.rimage .center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
  <title>Converting to NIMBLE from JAGS, OpenBUGS or WinBUGS</title>
</head>
<body>


<!--
Build with knit('converting_to_nimble.Rhtml').
Then copy and paste into blog post.
--> 

<h1> Converting to NIMBLE from JAGS, OpenBUGS or WinBUGS </h1>

<p> NIMBLE is a hierarchical modeling package that uses nearly the same modeling language as the popular MCMC packages WinBUGS, OpenBUGS and JAGS.  NIMBLE makes the modeling language extensible &mdash; you can add distributions and functions &mdash; and also allows customization of MCMC or other algorithms that use models.  Here is a quick summary of steps to convert existing code from WinBUGS, OpenBUGS or JAGS to NIMBLE. For more information, see examples on <a href="http://r-nimble.org">r-nimble.org</a> or the  <a href="https://r-nimble.org/manuals/NimbleUserManual.pdf">NIMBLE User Manual</a>. </p>

<h2> Main steps for converting existing code </h2>

<p> These steps assume you are familiar with running WinBUGS, OpenBUGS or JAGS through an R package such as R2WinBUGS, R2jags, rjags, or jagsUI. </p>

<ol>
<li>Wrap your model code in <tt>nimbleCode({})</tt>, directly in R.</li>
<ul>
    <li>This replaces the step of writing or generating a separate file containing the model code.</li>

    <li>Alternatively, you can read standard JAGS- and BUGS-formatted code and data files using
  <tt>readBUGSmodel</tt>.</li>
</ul>
<li> Provide information about missing or empty indices </li>
<ul>
    <li> Example: If <tt>x</tt> is a matrix, you must write at least <tt>x[,]</tt> to show it has two dimensions.</li>
    <li> If other declarations make the size of <tt>x</tt> clear, <tt>x[,]</tt> will work in some circumstances.</li>
    <li> If not, either provide index ranges (e.g. <tt>x[1:n, 1:m]</tt>) or use the <tt>dimensions</tt> argument to <tt>nimbleModel</tt> to provide the sizes in each dimension.</li>
</ul>
<li>  Choose how you want to run MCMC. </li>
<ul>
    <li> Use <tt>nimbleMCMC()</tt> as the just-do-it way to run an MCMC.  This will take all steps to
  set up and run an MCMC using   NIMBLE's default configuration.</li>
   
    <li> To use NIMBLE's full flexibility: build the model, configure and build the MCMC, and compile both the model and MCMC.  Then run the MCMC via <tt>runMCMC</tt> or by calling the <tt>run</tt> function of the compiled MCMC.  See the NIMBLE User Manual to learn more about what you can do.</li>
</ul>
</ol>

<p> See below for a list of some more nitty-gritty additional steps you may need to consider for some models. </p>

<h2> Example: An animal abundance model </h2>

<p> This example is adapted from Chapter 6, Section 6.4 of <a href="https://www.elsevier.com/books/applied-hierarchical-modeling-in-ecology-analysis-of-distribution-abundance-and-species-richness-in-r-and-bugs/kery/978-0-12-801378-6">Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS.  Volume I: Prelude and Static Models</a> by Marc K&#233;ry and J. Andrew Royle (2015, Academic Press).  The <a href="https://www.mbr-pwrc.usgs.gov/pubanalysis/keryroylebook/">book's web site</a> provides code for its examples. </p>

<h3> Original code </h3>

<p> The original model code looks like this: </p>

<pre><tt>
cat(file = "model2.txt","
model {
# Priors
for(k in 1:3){                # Loop over 3 levels of hab or time factors
   alpha0[k] ~ dunif(-10, 10) # Detection intercepts
   alpha1[k] ~ dunif(-10, 10) # Detection slopes
   beta0[k] ~ dunif(-10, 10)  # Abundance intercepts
   beta1[k] ~ dunif(-10, 10)  # Abundance slopes
}

# Likelihood
# Ecological model for true abundance
for (i in 1:M){
   N[i] ~ dpois(lambda[i])
   log(lambda[i]) <- beta0[hab[i]] + beta1[hab[i]] * vegHt[i]
   # Some intermediate derived quantities
   critical[i] <- step(2-N[i])# yields 1 whenever N is 2 or less
   z[i] <- step(N[i]-0.5)     # Indicator for occupied site
   # Observation model for replicated counts
   for (j in 1:J){
      C[i,j] ~ dbin(p[i,j], N[i])
      logit(p[i,j]) <- alpha0[j] + alpha1[j] * wind[i,j]
   }
}

# Derived quantities
Nocc <- sum(z[])         # Number of occupied sites among sample of M
Ntotal <- sum(N[])       # Total population size at M sites combined
Nhab[1] <- sum(N[1:33])  # Total abundance for sites in hab A
Nhab[2] <- sum(N[34:66]) # Total abundance for sites in hab B
Nhab[3] <- sum(N[67:100])# Total abundance for sites in hab C
for(k in 1:100){         # Predictions of lambda and p ...
   for(level in 1:3){    #    ... for each level of hab and time factors
      lam.pred[k, level] <- exp(beta0[level] + beta1[level] * XvegHt[k])
      logit(p.pred[k, level]) <- alpha0[level] + alpha1[level] * Xwind[k]
   }
}
N.critical <- sum(critical[]) # Number of populations with critical size
}")
</tt></pre>

<h3>Brief summary of the model</h3>

<p> This is known as an "N-mixture" model in ecology.  The details aren't really important for illustrating the mechanics of converting this model to NIMBLE, but here is a brief summary anyway.  The latent abundances <tt>N[i]</tt> at sites <tt>i = 1...M</tt> are assumed to follow a Poisson.  The  j-th count at the i-th site, <tt>C[i, j]</tt>, is assumed to follow a binomial with detection probability <tt>p[i, j]</tt>.  The abundance at each site depends on a habitat-specific intercept and coefficient for vegetation height, with a log link.  The detection probability for each sampling occasion depends on a date-specific intercept and coefficient for wind speed.  K&#233;ry and Royle concocted this as a simulated example to illustrate the hierarchical modeling approaches for estimating abundance from count data on repeated visits to multiple sites. </p>

<h2>NIMBLE version of the model code</h2>

<p>Here is the model converted for use in NIMBLE.  In this case, the only changes to the code are to insert some missing index ranges (see comments).</p>

<div class="chunk" id="nimble-code"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">library</span><span class="hl std">(nimble)</span>
<span class="hl std">Section6p4_code</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">nimbleCode</span><span class="hl std">( {</span>
    <span class="hl com"># Priors</span>
    <span class="hl kwa">for</span><span class="hl std">(k</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl std">) {</span>                <span class="hl com"># Loop over 3 levels of hab or time factors</span>
      <span class="hl std">alpha0[k]</span> <span class="hl opt">~</span> <span class="hl kwd">dunif</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">10</span><span class="hl std">,</span> <span class="hl num">10</span><span class="hl std">)</span> <span class="hl com"># Detection intercepts</span>
      <span class="hl std">alpha1[k]</span> <span class="hl opt">~</span> <span class="hl kwd">dunif</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">10</span><span class="hl std">,</span> <span class="hl num">10</span><span class="hl std">)</span> <span class="hl com"># Detection slopes</span>
      <span class="hl std">beta0[k]</span> <span class="hl opt">~</span> <span class="hl kwd">dunif</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">10</span><span class="hl std">,</span> <span class="hl num">10</span><span class="hl std">)</span>  <span class="hl com"># Abundance intercepts</span>
      <span class="hl std">beta1[k]</span> <span class="hl opt">~</span> <span class="hl kwd">dunif</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">10</span><span class="hl std">,</span> <span class="hl num">10</span><span class="hl std">)</span>  <span class="hl com"># Abundance slopes</span>
    <span class="hl std">}</span>

    <span class="hl com"># Likelihood</span>
    <span class="hl com"># Ecological model for true abundance</span>
    <span class="hl kwa">for</span> <span class="hl std">(i</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl std">M){</span>
      <span class="hl std">N[i]</span> <span class="hl opt">~</span> <span class="hl kwd">dpois</span><span class="hl std">(lambda[i])</span>
      <span class="hl kwd">log</span><span class="hl std">(lambda[i])</span> <span class="hl kwb">&lt;-</span> <span class="hl std">beta0[hab[i]]</span> <span class="hl opt">+</span> <span class="hl std">beta1[hab[i]]</span> <span class="hl opt">*</span> <span class="hl std">vegHt[i]</span>
      <span class="hl com"># Some intermediate derived quantities</span>
      <span class="hl std">critical[i]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">step</span><span class="hl std">(</span><span class="hl num">2</span><span class="hl opt">-</span><span class="hl std">N[i])</span><span class="hl com"># yields 1 whenever N is 2 or less</span>
      <span class="hl std">z[i]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">step</span><span class="hl std">(N[i]</span><span class="hl opt">-</span><span class="hl num">0.5</span><span class="hl std">)</span>     <span class="hl com"># Indicator for occupied site</span>
      <span class="hl com"># Observation model for replicated counts</span>
      <span class="hl kwa">for</span> <span class="hl std">(j</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl std">J){</span>
        <span class="hl std">C[i,j]</span> <span class="hl opt">~</span> <span class="hl kwd">dbin</span><span class="hl std">(p[i,j], N[i])</span>
        <span class="hl kwd">logit</span><span class="hl std">(p[i,j])</span> <span class="hl kwb">&lt;-</span> <span class="hl std">alpha0[j]</span> <span class="hl opt">+</span> <span class="hl std">alpha1[j]</span> <span class="hl opt">*</span> <span class="hl std">wind[i,j]</span>
        <span class="hl std">}</span>
    <span class="hl std">}</span>

    <span class="hl com"># Derived quantities; unnececssary when running for inference purpose</span>
    <span class="hl com"># NIMBLE: We have filled in indices in the next two lines.</span>
    <span class="hl std">Nocc</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(z[</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">100</span><span class="hl std">])</span>         <span class="hl com"># Number of occupied sites among sample of M</span>
    <span class="hl std">Ntotal</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(N[</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">100</span><span class="hl std">])</span>       <span class="hl com"># Total population size at M sites combined</span>
    <span class="hl std">Nhab[</span><span class="hl num">1</span><span class="hl std">]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(N[</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">33</span><span class="hl std">])</span>  <span class="hl com"># Total abundance for sites in hab A</span>
    <span class="hl std">Nhab[</span><span class="hl num">2</span><span class="hl std">]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(N[</span><span class="hl num">34</span><span class="hl opt">:</span><span class="hl num">66</span><span class="hl std">])</span> <span class="hl com"># Total abundance for sites in hab B</span>
    <span class="hl std">Nhab[</span><span class="hl num">3</span><span class="hl std">]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(N[</span><span class="hl num">67</span><span class="hl opt">:</span><span class="hl num">100</span><span class="hl std">])</span><span class="hl com"># Total abundance for sites in hab C</span>
    <span class="hl kwa">for</span><span class="hl std">(k</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">100</span><span class="hl std">){</span>         <span class="hl com"># Predictions of lambda and p ...</span>
      <span class="hl kwa">for</span><span class="hl std">(level</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl std">){</span>    <span class="hl com">#    ... for each level of hab and time factors</span>
        <span class="hl std">lam.pred[k, level]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">exp</span><span class="hl std">(beta0[level]</span> <span class="hl opt">+</span> <span class="hl std">beta1[level]</span> <span class="hl opt">*</span> <span class="hl std">XvegHt[k])</span>
        <span class="hl kwd">logit</span><span class="hl std">(p.pred[k, level])</span> <span class="hl kwb">&lt;-</span> <span class="hl std">alpha0[level]</span> <span class="hl opt">+</span> <span class="hl std">alpha1[level]</span> <span class="hl opt">*</span> <span class="hl std">Xwind[k]</span>
        <span class="hl std">}</span>
      <span class="hl std">}</span>
    <span class="hl com"># NIMBLE: We have filled in indices in the next line. </span>
    <span class="hl std">N.critical</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sum</span><span class="hl std">(critical[</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">100</span><span class="hl std">])</span> <span class="hl com"># Number of populations with critical size</span>
  <span class="hl std">})</span>
</pre></div>
</div></div>

<h2> Simulated data </h2>

<p> To carry this example further, we need some simulated data.  K&#233;ry and Royle provide separate code to do this.  With NIMBLE we could use the model itself to simulate data rather than writing separate simulation code.  But for our goals here, we simply copy K&#233;ry and Royle's simulation code, and we compact it somewhat: </p>

<div class="chunk" id="simulate-data"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl com"># Code from Kery and Royle (2015)</span>
<span class="hl com"># Choose sample sizes and prepare obs. data array y</span>
<span class="hl kwd">set.seed</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">)</span>                   <span class="hl com"># So we all get same data set</span>
<span class="hl std">M</span> <span class="hl kwb">&lt;-</span> <span class="hl num">100</span>                      <span class="hl com"># Number of sites</span>
<span class="hl std">J</span> <span class="hl kwb">&lt;-</span> <span class="hl num">3</span>                        <span class="hl com"># Number of repeated abundance measurements</span>
<span class="hl std">C</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">matrix</span><span class="hl std">(</span><span class="hl num">NA</span><span class="hl std">,</span> <span class="hl kwc">nrow</span> <span class="hl std">= M,</span> <span class="hl kwc">ncol</span> <span class="hl std">= J)</span> <span class="hl com"># to contain the observed data</span>

<span class="hl com"># Create a covariate called vegHt</span>
<span class="hl std">vegHt</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">sort</span><span class="hl std">(</span><span class="hl kwd">runif</span><span class="hl std">(M,</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">1</span><span class="hl std">))</span> <span class="hl com"># sort for graphical convenience</span>

<span class="hl com"># Choose parameter values for abundance model and compute lambda</span>
<span class="hl std">beta0</span> <span class="hl kwb">&lt;-</span> <span class="hl num">0</span>                    <span class="hl com"># Log-scale intercept</span>
<span class="hl std">beta1</span> <span class="hl kwb">&lt;-</span> <span class="hl num">2</span>                    <span class="hl com"># Log-scale slope for vegHt</span>
<span class="hl std">lambda</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">exp</span><span class="hl std">(beta0</span> <span class="hl opt">+</span> <span class="hl std">beta1</span> <span class="hl opt">*</span> <span class="hl std">vegHt)</span> <span class="hl com"># Expected abundance</span>

<span class="hl com"># Draw local abundance</span>
<span class="hl std">N</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">rpois</span><span class="hl std">(M, lambda)</span>

<span class="hl com"># Create a covariate called wind</span>
<span class="hl std">wind</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">array</span><span class="hl std">(</span><span class="hl kwd">runif</span><span class="hl std">(M</span> <span class="hl opt">*</span> <span class="hl std">J,</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">1</span><span class="hl std">),</span> <span class="hl kwc">dim</span> <span class="hl std">=</span> <span class="hl kwd">c</span><span class="hl std">(M, J))</span>

<span class="hl com"># Choose parameter values for measurement error model and compute detectability</span>
<span class="hl std">alpha0</span> <span class="hl kwb">&lt;-</span> <span class="hl opt">-</span><span class="hl num">2</span>                        <span class="hl com"># Logit-scale intercept</span>
<span class="hl std">alpha1</span> <span class="hl kwb">&lt;-</span> <span class="hl opt">-</span><span class="hl num">3</span>                        <span class="hl com"># Logit-scale slope for wind</span>
<span class="hl std">p</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">plogis</span><span class="hl std">(alpha0</span> <span class="hl opt">+</span> <span class="hl std">alpha1</span> <span class="hl opt">*</span> <span class="hl std">wind)</span> <span class="hl com"># Detection probability</span>

<span class="hl com"># Take J = 3 abundance measurements at each site</span>
<span class="hl kwa">for</span><span class="hl std">(j</span> <span class="hl kwa">in</span> <span class="hl num">1</span><span class="hl opt">:</span><span class="hl std">J) {</span>
  <span class="hl std">C[,j]</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">rbinom</span><span class="hl std">(M, N, p[,j])</span>
<span class="hl std">}</span>

<span class="hl com"># Create factors</span>
<span class="hl std">time</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">matrix</span><span class="hl std">(</span><span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl kwd">as.character</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl std">J), M),</span> <span class="hl kwc">ncol</span> <span class="hl std">= J,</span> <span class="hl kwc">byrow</span> <span class="hl std">=</span> <span class="hl num">TRUE</span><span class="hl std">)</span>
<span class="hl std">hab</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">c</span><span class="hl std">(</span><span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl str">&quot;A&quot;</span><span class="hl std">,</span> <span class="hl num">33</span><span class="hl std">),</span> <span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl str">&quot;B&quot;</span><span class="hl std">,</span> <span class="hl num">33</span><span class="hl std">),</span> <span class="hl kwd">rep</span><span class="hl std">(</span><span class="hl str">&quot;C&quot;</span><span class="hl std">,</span> <span class="hl num">34</span><span class="hl std">))</span>  <span class="hl com"># assumes M = 100</span>

<span class="hl com"># Bundle data</span>
<span class="hl com"># NIMBLE: For full flexibility, we could separate this list</span>
<span class="hl com">#         into constants and data lists.  For simplicity we will keep</span>
<span class="hl com">#         it as one list to be provided as the &quot;constants&quot; argument.</span>
<span class="hl com">#         See comments about how we would split it if desired.</span>
<span class="hl std">win.data</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">list</span><span class="hl std">(</span>
    <span class="hl com">## NIMBLE: C is the actual data</span>
    <span class="hl kwc">C</span> <span class="hl std">= C,</span>
    <span class="hl com">## NIMBLE: Covariates can be data or constants</span>
    <span class="hl com">##         If they are data, you could modify them after the model is built</span>
    <span class="hl kwc">wind</span> <span class="hl std">= wind,</span>
    <span class="hl kwc">vegHt</span> <span class="hl std">= vegHt,</span>
    <span class="hl kwc">XvegHt</span> <span class="hl std">=</span> <span class="hl kwd">seq</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">1</span><span class="hl std">,,</span> <span class="hl num">100</span><span class="hl std">),</span> <span class="hl com"># Used only for derived quantities</span>
    <span class="hl kwc">Xwind</span> <span class="hl std">=</span> <span class="hl kwd">seq</span><span class="hl std">(</span><span class="hl opt">-</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl num">1</span><span class="hl std">,,</span><span class="hl num">100</span><span class="hl std">),</span>   <span class="hl com"># Used only for derived quantities</span>
    <span class="hl com">## NIMBLE: The rest of these are constants, needed for model definition</span>
    <span class="hl com">## We can provide them in the same list and NIMBLE will figure it out.</span>
    <span class="hl kwc">M</span> <span class="hl std">=</span> <span class="hl kwd">nrow</span><span class="hl std">(C),</span>
    <span class="hl kwc">J</span> <span class="hl std">=</span> <span class="hl kwd">ncol</span><span class="hl std">(C),</span>
    <span class="hl kwc">hab</span> <span class="hl std">=</span> <span class="hl kwd">as.numeric</span><span class="hl std">(</span><span class="hl kwd">factor</span><span class="hl std">(hab))</span>
<span class="hl std">)</span>
</pre></div>
</div></div>

<h2> Initial values </h2>

<p> Next we need to set up initial values and choose parameters to monitor in the MCMC output.  To do so we will again directly use  K&#233;ry and Royle's code.</p>

<div class="chunk" id="setup-inits-params"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">Nst</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">apply</span><span class="hl std">(C,</span> <span class="hl num">1</span><span class="hl std">, max)</span><span class="hl opt">+</span><span class="hl num">1</span>   <span class="hl com"># Important to give good inits for latent N</span>
<span class="hl std">inits</span> <span class="hl kwb">&lt;-</span> <span class="hl kwa">function</span><span class="hl std">()</span> <span class="hl kwd">list</span><span class="hl std">(</span><span class="hl kwc">N</span> <span class="hl std">= Nst,</span>
                         <span class="hl kwc">alpha0</span> <span class="hl std">=</span> <span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">),</span>
                         <span class="hl kwc">alpha1</span> <span class="hl std">=</span> <span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">),</span>
                         <span class="hl kwc">beta0</span> <span class="hl std">=</span> <span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">),</span>
                         <span class="hl kwc">beta1</span> <span class="hl std">=</span> <span class="hl kwd">rnorm</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">))</span>

<span class="hl com"># Parameters monitored</span>
<span class="hl com"># could also estimate N, bayesian counterpart to BUPs before: simply add &quot;N&quot; to the list</span>
<span class="hl std">params</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;alpha0&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;alpha1&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;beta0&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;beta1&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;Nocc&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;Ntotal&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;Nhab&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;N.critical&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;lam.pred&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;p.pred&quot;</span><span class="hl std">)</span>
</pre></div>
</div></div>

<h2> Run MCMC with <tt>nimbleMCMC</tt> </h2>

<p> Now we are ready to run an MCMC in nimble.  We will run only one chain, using the same settings as  K&#233;ry and Royle. </p>


<div class="chunk" id="nimble-mcmc"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">samples</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">nimbleMCMC</span><span class="hl std">(</span>
    <span class="hl kwc">code</span> <span class="hl std">= Section6p4_code,</span>
    <span class="hl kwc">constants</span> <span class="hl std">= win.data,</span> <span class="hl com">## provide the combined data &amp; constants as constants</span>
    <span class="hl kwc">inits</span> <span class="hl std">= inits,</span>
    <span class="hl kwc">monitors</span> <span class="hl std">= params,</span>
    <span class="hl kwc">niter</span> <span class="hl std">=</span> <span class="hl num">22000</span><span class="hl std">,</span>
    <span class="hl kwc">nburnin</span> <span class="hl std">=</span> <span class="hl num">2000</span><span class="hl std">,</span>
    <span class="hl kwc">thin</span> <span class="hl std">=</span> <span class="hl num">10</span><span class="hl std">)</span>
</pre></div>
<div class="message"><pre class="knitr r">## defining model...
</pre></div>
<div class="output"><pre class="knitr r">## Detected C as data within 'constants'.
</pre></div>
<div class="message"><pre class="knitr r">## Adding C as data for building model.
</pre></div>
<div class="message"><pre class="knitr r">## building model...
</pre></div>
<div class="message"><pre class="knitr r">## setting data and initial values...
</pre></div>
<div class="message"><pre class="knitr r">## running calculate on model (any error reports that follow may simply reflect missing values in model variables) ... 
## checking model sizes and dimensions...
## checking model calculations...
## model building finished.
## compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
## compilation finished.
## runMCMC's handling of nburnin changed in nimble version 0.6-11. Previously, nburnin samples were discarded *post-thinning*.  Now nburnin samples are discarded *pre-thinning*.  The number of samples returned will be floor((niter-nburnin)/thin).
## running chain 1...
</pre></div>
<div class="output"><pre class="knitr r">## |-------------|-------------|-------------|-------------|
## |-------------------------------------------------------|
</pre></div>
</div></div>

<h2> Work with the samples </h2>

<p> Finally we want to look at our samples.  NIMBLE returns samples as a simple matrix with named columns.  There are numerous packages for processing MCMC output.  If you want to use the <tt>coda</tt> package, you can convert a matrix to a coda mcmc object like this: </p> 

<div class="chunk" id="code"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">library</span><span class="hl std">(coda)</span>
<span class="hl std">coda.samples</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">as.mcmc</span><span class="hl std">(samples)</span>
</pre></div>
</div></div>

<p>Alternatively, if you call <tt>nimbleMCMC</tt> with the argument  <tt>samplesAsCodaMCMC = TRUE</tt>, the samples will be returned as a coda object.</p>

<p>To show that MCMC really happened, here is a plot of <tt>N.critical</tt>:</p>
<div class="chunk" id="simple-plot"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">plot</span><span class="hl std">(</span><span class="hl kwd">jitter</span><span class="hl std">(samples[,</span> <span class="hl str">&quot;N.critical&quot;</span><span class="hl std">]),</span> <span class="hl kwc">xlab</span> <span class="hl std">=</span> <span class="hl str">&quot;iteration&quot;</span><span class="hl std">,</span> <span class="hl kwc">ylab</span> <span class="hl std">=</span> <span class="hl str">&quot;N.critical&quot;</span><span class="hl std">,</span>
     <span class="hl kwc">main</span> <span class="hl std">=</span> <span class="hl str">&quot;Number of populations with critical size&quot;</span><span class="hl std">,</span>
     <span class="hl kwc">type</span> <span class="hl std">=</span> <span class="hl str">&quot;l&quot;</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/simple-plot-1.png" title="plot of chunk simple-plot" alt="plot of chunk simple-plot" class="plot" /></div></div>

<h1> Next steps </h1>
<p> NIMBLE allows users to customize MCMC and other algorithms in many ways.  See the NIMBLE User Manual and web site for more ideas. </p>

<h2> Smaller steps you may need for converting existing code</h2>

<p>If the main steps above aren't sufficient, consider these additional steps when converting from JAGS, WinBUGS or OpenBUGS to NIMBLE.</p>

<ol start = "4">
<li> Convert any use of truncation syntax
<ul>
    <li> e.g. <tt>x ~ dnorm(0, tau) T(a, b)</tt> should be re-written as <tt>x ~ T(dnorm(0, tau), a, b)</tt>.</li>

    <li> If reading model code from a file using <tt>readBUGSmodel</tt>, the <tt>x ~ dnorm(0, tau) T(a, b)</tt>  syntax will work.</li>
</ul>
</li>

<li> Possibly split the <tt>data</tt> into <tt>data</tt> and <tt>constants</tt> for NIMBLE.
<ul>
    <li> NIMBLE has a more general concept of data, so NIMBLE makes a distinction between data and constants. </li>
    <li> Constants are necessary to define the model, such as <tt>nsite</tt> in <tt>for(i in 1:nsite) {...}</tt> and constant vectors of factor indices (e.g. <tt>block</tt> in <tt>mu[block[i]]</tt>). </li>
    <li> Data are observed values of some variables.</li>
    <li> Alternatively, one can provide a list of both constants and data for the <tt>constants</tt> argument to <tt>nimbleModel</tt>, and NIMBLE will try to determine which is which.  Usually this will work, but when in doubt, try separating them. </li>
</ul>
</li>
<li>  Possibly update initial values (<tt>inits</tt>).
<ul>
    <li> In some cases, NIMBLE likes to have more complete <tt>inits</tt> than the other packages.</li>
    <li> In a model with stochastic indices, those indices should have <tt>inits</tt> values.</li>
    <li> When using <tt>nimbleMCMC</tt> or <tt>runMCMC</tt>, <tt>inits</tt> can be a function, as in R packages for calling WinBUGS, OpenBUGS or JAGS.  Alternatively, it can be a list.</li>
    <li> When you build a model with <tt>nimbleModel</tt> for more control than <tt>nimbleMCMC</tt>, you can provide <tt>inits</tt> as a list.  This sets defaults that can be over-ridden with the <tt>inits</tt> argument to <tt>runMCMC</tt>.</li>
</ul>
</li>
</ol>

</body>
</html>
